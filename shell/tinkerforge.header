#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Matthias Bolte <matthias@tinkerforge.com>
#
# Redistribution and use in source and binary forms of this file,
# with or without modification, are permitted.

import sys
import os
import time

current_parser = None

def fatal(message, exit_code=1):
	if current_parser is not None:
		prog = current_parser.prog
	else:
		prog = 'tinkerforge'

	sys.stderr.write('{0}: error: {1}\n'.format(prog, message))
	sys.exit(exit_code)

if sys.hexversion < 0x02050000:
	fatal('requiring python 2.5 or newer', 21)

try:
	import argparse
except ImportError:
	fatal('requiring python argparse module', 22)

host = None
port = None
timeout = None
duration = None
uid = None
item_separator = None
group_separator = None
no_symbolic_input = None
no_symbolic_output = None

class Parser(argparse.ArgumentParser):
	def __init__(self, prog, description=None, epilog=None):
		argparse.ArgumentParser.__init__(self, prog=prog, add_help=False, description=description, epilog=epilog)

		global current_parser
		current_parser = self

		self.add_argument('--help', action='help', help='show this help message and exit')

class ParserWithExecute(Parser):
	def __init__(self, prog):
		Parser.__init__(self, prog)

		self.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

class ParserWithExpectResponse(Parser):
	def __init__(self, prog):
		Parser.__init__(self, prog)

		self.add_argument('--expect-response', action='store_true', help='request response and wait for it')

def call_generic(name, functions, argv):
	parser = Parser('tinkerforge call ' + name)
	function_choices = sorted(functions.keys())

	class ListFunctionsAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			print('\n'.join(function_choices))
			parser.exit()

	parser.add_argument('--list-functions', action=ListFunctionsAction, nargs=0, help='show functions of {0} and exit'.format(name))
	parser.add_argument('uid', type=check_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('function', choices=function_choices, help='{' + ', '.join(function_choices) + '}', metavar='<function>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='function specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	global uid
	uid = args.uid

	functions[args.function](args.args)

def dispatch_generic(name, callbacks, argv):
	parser = Parser('tinkerforge dispatch ' + name)
	callback_choices = sorted(callbacks.keys())

	class ListCallbacksAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			print('\n'.join(callback_choices))
			parser.exit()

	parser.add_argument('--list-callbacks', action=ListCallbacksAction, nargs=0, help='show callbacks of {0} and exit'.format(name))
	parser.add_argument('uid', type=check_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('callback', choices=callback_choices, help='{' + ', '.join(callback_choices) + '}', metavar='<callback>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='callback specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	global uid
	uid = args.uid

	callbacks[args.callback](args.args)

def device_send_request(device_class, function_id, request_data, format_in,
                        format_out, command, expect_response, names, symbols):
	if command is not None:
		def handle_result(values):
			execute_result(command, names, values)
	else:
		def handle_result(values):
			print_result(names, values)

	try:
		ipcon = IPConnection()
		ipcon.set_timeout(timeout / 1000.0)
		ipcon.connect(host, port)

		device = device_class(uid, ipcon)

		if expect_response:
			device.set_response_expected(function_id, True)

		result = ipcon.send_request(device, function_id, request_data, format_in, format_out)

		if result is not None:
			if len(names) == 1:
				result = (result,)

			result = format_symbolic_output(result, symbols)

			handle_result(result)
	except Error as e:
		fatal(e.description.lower(), 200 - e.value)
	except socket.error as e:
		fatal(str(e).lower(), 23)
	except Exception as e:
		fatal(str(e).lower(), 24)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def device_callback(device_class, function_id, command, names):
	if command is not None:
		def callback(*values):
			execute_result(command, names, values)
	else:
		is_first_callback = [True]

		def callback(*values):
			if len(names) > 1:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					sys.stdout.write(group_separator)

			print_result(names, values)

	try:
		ipcon = IPConnection()
		ipcon.connect(host, port)

		device = device_class(uid, ipcon)

		if duration == 0:
			exit_flag = [False]

			def callback_wapper(*args, **kwargs):
				if not exit_flag[0]:
					callback(*args, **kwargs)
					exit_flag[0] = True

			device.registered_callbacks[function_id] = callback_wapper

			while not exit_flag[0]:
				time.sleep(0.1)
		elif duration < 0:
			device.registered_callbacks[function_id] = callback

			while True:
				time.sleep(1)
		else:
			device.registered_callbacks[function_id] = callback

			time.sleep(duration / 1000.0)
	except Error as e:
		fatal(e.description.lower(), 200 - e.value)
	except socket.error as e:
		fatal(str(e).lower(), 23)
	except Exception as e:
		fatal(str(e).lower(), 24)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

# length_is_fixed = False means length is maximum length
def get_array_type_name(name, length, length_is_fixed=True):
	if length_is_fixed:
		if length < 7:
			return item_separator.join([name]*length)
		else:
			return '{0}{1}{0}{1}..{2}x..{1}{0}{1}{0}'.format(name, item_separator, length - 4)
	else:
		return ('[' + item_separator).join([name]*length) + ']'*(length - 1)

def format_symbolic_output(values, symbols):
	if no_symbolic_output:
		return values

	translated_values = []

	for vs in zip(values, symbols):
		if vs[1] is not None:
			try:
				translated_values.append(vs[1][vs[0]])
			except KeyError:
				translated_values.append(vs[0])
		else:
			translated_values.append(vs[0])

	return tuple(translated_values)

def check_base58(string):
	try:
		base58decode(string)
	except:
		msg = 'invalid base58 value: %r' % string
		raise argparse.ArgumentTypeError(msg)

	return string

check_base58.__name__ = 'base58'

def check_char(string):
	if len(string) != 1:
		msg = 'invalid char value: %r' % string
		raise argparse.ArgumentTypeError(msg)

	return string

check_char.__name__ = 'char'

def convert_bool(string):
	value = string.lower()

	if value == 'true':
		return True
	elif value == 'false':
		return False
	else:
		msg = 'invalid bool value: %r' % string
		raise argparse.ArgumentTypeError(msg)

convert_bool.__name__ = 'bool'

def create_string_checker(type, length):
	def check_string(string):
		try:
			value = type(string)
		except (ValueError, TypeError):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if len(value) > length:
			msg = 'string value is too long: %r' % value
			raise argparse.ArgumentTypeError(msg)

		return value

	check_string.__name__ = 'string'

	return check_string

def create_symbol_converter(type, symbols, strict=False):
	def convert_symbol(string):
		if not no_symbolic_input:
			try:
				return symbols[string]
			except KeyError:
				pass

		try:
			value = type(string)
		except (ValueError, TypeError):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if strict and value not in symbols.values():
			name = getattr(type, '__name__', repr(type))
			msg = '%s value is out-of-range: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		return value

	convert_symbol.__name__ = getattr(type, '__name__', repr(type))

	return convert_symbol

# length_is_fixed = False means length is maximum length
def create_array_converter(type, length, length_is_fixed=True):
	def convert_array(string):
		array = []

		for item in string.split(item_separator):
			try:
				value = type(item)
			except (ValueError, TypeError, argparse.ArgumentTypeError):
				name = getattr(type, '__name__', repr(type))
				msg = 'invalid %s value: %r' % (get_array_type_name(name, length, length_is_fixed), string)
				raise argparse.ArgumentTypeError(msg)

			array.append(value)

		if (length_is_fixed and len(array) != length) or \
		   (not length_is_fixed and (len(array) < 1 or len(array) > length)):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (get_array_type_name(name, length, length_is_fixed), string)
			raise argparse.ArgumentTypeError(msg)

		return array

	name = getattr(type, '__name__', repr(type))
	convert_array.__name__ = get_array_type_name(name, length, length_is_fixed)

	return convert_array

def execute_result(command, names, values):
	result = {}

	class Tuple(tuple):
		def __init__(self, *args):
			tuple.__init__(self, *args)

		def __str__(self):
			return item_separator.join(map(str, self))

	for name, value in zip(names, values):
		if type(value) == tuple:
			result[name] = Tuple(value)
		elif type(value) == bool:
			result[name] = str(value).lower()
		else:
			result[name] = value

	try:
		formatted_command = command.format(**result)
	except KeyError as e:
		fatal('invalid placeholder %s in format: %s' % (str(e).lower(), command), 25)
	except Exception as e:
		fatal('%s: %s' % (str(e).lower(), command), 24)

	os.system(formatted_command)

def print_result(names, values):
	for name, value in zip(names, values):
		if type(value) == tuple:
			print('{0}={1}'.format(name, item_separator.join(map(str, value))))
		elif type(value) == bool:
			print('{0}={1}'.format(name, str(value).lower()))
		else:
			print('{0}={1}'.format(name, value))

def common_get_identity(prog_prefix, klass, argv):
	parser = ParserWithExecute(prog_prefix + ' get-identity')

	args = parser.parse_args(argv)

	device_send_request(klass, 255, (), '', '8s 8s c 3B 3B H', args.execute, False,
	                    ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier'],
	                    [None, None, None, None, None, device_identifier_symbols])


def command_call(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'call')
	device_choices = sorted(call_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--timeout', default=2500, type=int, help='maximum time (msec) to wait for response, default: 2500', metavar='<timeout>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.timeout = args.timeout

	call_devices[args.device](ctx, args.args)

def command_dispatch(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'dispatch')
	device_choices = sorted(dispatch_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--duration', default=-1, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate callbacks (exit-after-first: 0, forever: -1), default: forever', metavar='<duration>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.duration = args.duration

	dispatch_devices[args.device](ctx, args.args)

def command_enumerate(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'enumerate')

	enumeration_type_symbols = {
	'available': IPConnection.ENUMERATION_TYPE_AVAILABLE,
	'connected': IPConnection.ENUMERATION_TYPE_CONNECTED,
	'disconnected': IPConnection.ENUMERATION_TYPE_DISCONNECTED
	}

	parser.add_argument('--duration', default=250, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate responses (exit-after-first: 0, forever: -1), default: 250', metavar='<duration>')
	parser.add_argument('--types', default=[IPConnection.ENUMERATION_TYPE_AVAILABLE], type=create_array_converter(ctx, create_symbol_converter(ctx, int, enumeration_type_symbols, True), 3, False), help='array of enumeration types to dispatch (available: 0, connected: 1, disconnected: 2), default: available', metavar='<types>')

	if enable_execute:
		parser.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	namespace = argparse.Namespace()

	if not enable_execute:
		setattr(namespace, 'execute', None)

	args = parser.parse_args(argv, namespace)

	if dry_run:
		return

	names = ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier', 'enumeration-type']
	enumeration_type_symbols = {
	IPConnection.ENUMERATION_TYPE_AVAILABLE: 'available',
	IPConnection.ENUMERATION_TYPE_CONNECTED: 'connected',
	IPConnection.ENUMERATION_TYPE_DISCONNECTED: 'disconnected'
	}
	symbols = [None, None, None, None, None, device_identifier_symbols, enumeration_type_symbols]
	is_first_callback = [True]

	if args.execute is not None:
		def callback(*values):
			if values[6] in args.types:
				values = format_symbolic_output(ctx, values, symbols)

				execute_response(ctx, args.execute, names, values)
				return True
	else:
		def callback(*values):
			if values[6] in args.types:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					ctx.output(ctx.group_separator)

				values = format_symbolic_output(ctx, values, symbols)

				output_response(ctx, names, values)
				return True

	try:
		ipcon = IPConnection()
		ipcon.connect(ctx.host, ctx.port)

		if args.duration == 0:
			exit_flag = [False]

			def callback_wapper(*args, **kwargs):
				if not exit_flag[0] and callback(*args, **kwargs):
					exit_flag[0] = True

			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback_wapper)
			ipcon.enumerate()

			while not exit_flag[0] and not ctx.abort:
				time.sleep(0.1)
		elif args.duration < 0:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			while not ctx.abort:
				time.sleep(1)
		else:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			time.sleep(args.duration / 1000.0)
	except Error as e:
		raise FatalError(e.description.lower(), IPCONNECTION_ERROR_OFFSET - e.value)
	except socket.error as e:
		raise FatalError(str(e).lower(), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def command_listen(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'listen', epilog="In listen mode the --execute option for getter calls and callback dispatching is disabled by default, use --enable-execute to enable it.")

	parser.add_argument('--address', default='0.0.0.0', type=str, help='IP address to listen to, default: 0.0.0.0', metavar='<host>')
	parser.add_argument('--port', default=4217, type=int, help='port number to listen to, default: 4217', metavar='<port>')
	parser.add_argument('--enable-execute', action='store_true', help='enables --execute option for getters and callbacks')

	args = parser.parse_args(argv)

	global listen_mode
	listen_mode = True

	global enable_execute
	enable_execute = args.enable_execute

	global line_separator
	line_separator = '\t'

	try:
		server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		server_socket.bind((args.address, args.port))
		server_socket.listen(10)
	except socket.error as e:
		raise FatalError(str(e).lower(), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)

	def client_loop():
		if sys.hexversion < 0x03000000:
			pending_data = ''
		else:
			pending_data = bytes()

		try:
			client_socket, client_address = server_socket.accept()
		except socket.error:
			return

		print('{0} connected'.format(client_address[0]))

		while True:
			try:
				data = client_socket.recv(1024)
			except socket.error as e:
				print('{0} disconnected by socket error: {1}'.format(client_address[0], str(e).lower()))
				return
			except Exception as e:
				print('{0} disconnected by exception: {1}'.format(client_address[0], str(e).lower()))
				return

			if len(data) == 0:
				print('{0} disconnected'.format(client_address[0]))
				return

			pending_data += data

			while len(pending_data) > 0:
				i = pending_data.find(group_terminator)

				if i < 0:
					break

				command = pending_data[:i]
				pending_data = pending_data[i + len(group_terminator):]

				print('{0} sent {1}'.format(client_address[0], repr(command + group_terminator)))

				client_ctx = Context()

				def output_to_socket(string):
					if client_ctx.abort:
						return

					try:
						client_socket.sendall(string)
					except socket.error as e:
						print('socket error while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e).lower()))

						client_ctx.abort = True
						return
					except Exception as e:
						print('exception while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e).lower()))

						client_ctx.abort = True
						return

					print('{0} sent to {1}'.format(repr(string), client_address[0]))

				client_ctx.output = output_to_socket

				try:
					parse(client_ctx, shlex.split(command))
				except ParserExit:
					pass
				except FatalError as e:
					output_to_socket('error {0}: {1}{2}'.format(e.exit_code, e.message, group_terminator))

				if client_ctx.abort:
					return

	while True:
		ready, _, _ = select.select([server_socket], [], [])

		if server_socket not in ready:
			continue

		try:
			client_thread = threading.Thread(name='Client-Processor', target=client_loop)
			client_thread.daemon = True
			client_thread.start()
		except Exception as e:
			raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)

def parse(ctx, argv):
	global dry_run
	dry_run = os.getenv('TINKERFORGE_SHELL_BINDINGS_DRY_RUN', 0) != 0

	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	parser = Parser(ctx, '', epilog="Try '{0}<command> --help' for command specific help.".format(prefix))
	command_choices = ['call', 'dispatch', 'enumerate']

	if not listen_mode:
		command_choices.append('listen')

	parser.add_argument('--version', action='version', version='<<VERSION>>')
	parser.add_argument('--host', default='localhost', type=str, help='IP address or hostname to connect to, default: localhost', metavar='<host>')
	parser.add_argument('--port', default=4223, type=int, help='port number to connect to, default: 4223', metavar='<port>')
	parser.add_argument('--item-separator', default=',', type=str, help='separator for array items, default: , (comma)', metavar='<item-separator>')
	parser.add_argument('--group-separator', default='\n', type=str, help='separator for output groups, default: \\n (newline)', metavar='<group-separator>')
	parser.add_argument('--no-symbolic-input', action='store_true', help='disable symbolic input of values')
	parser.add_argument('--no-symbolic-output', action='store_true', help='disable symbolic output of values')

	parser.add_argument('command', choices=command_choices, help='{' + ', '.join(command_choices) + '}', metavar='<command>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='command specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.host = args.host
	ctx.port = args.port

	ctx.item_separator = args.item_separator
	ctx.item_separator = ctx.item_separator.replace('\\t', '\t')
	ctx.item_separator = ctx.item_separator.replace('\\r', '\r')
	ctx.item_separator = ctx.item_separator.replace('\\n', '\n')
	ctx.item_separator = ctx.item_separator.replace('\\\\', '\\')

	ctx.group_separator = args.group_separator
	ctx.group_separator = ctx.group_separator.replace('\\t', '\t')
	ctx.group_separator = ctx.group_separator.replace('\\r', '\r')
	ctx.group_separator = ctx.group_separator.replace('\\n', '\n')
	ctx.group_separator = ctx.group_separator.replace('\\\\', '\\')

	ctx.no_symbolic_input = args.no_symbolic_input
	ctx.no_symbolic_output = args.no_symbolic_output

	commands = {
	'call': command_call,
	'dispatch': command_dispatch,
	'enumerate': command_enumerate
	}

	if not listen_mode:
		commands['listen'] = command_listen

	commands[args.command](ctx, args.args)

def terminate(signal=None, frame=None):
	sys.exit(ERROR_INTERRUPTED)

def main():
	signal.signal(signal.SIGINT, terminate)
	signal.signal(signal.SIGTERM, terminate)

	ctx = Context()

	try:
		parse(ctx, sys.argv[1:])
	except KeyboardInterrupt:
		sys.exit(ERROR_INTERRUPTED)
	except ParserExit:
		sys.exit(0)
	except FatalError as e:
		if ctx.current_parser is not None:
			prog = ctx.current_parser.prog
		else:
			prog = 'tinkerforge'

		sys.stderr.write('{0}: error: {1}\n'.format(prog, e.message))
		sys.exit(e.exit_code)

if __name__ == '__main__':
	main()

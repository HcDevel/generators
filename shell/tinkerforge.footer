
def command_call(argv):
	parser = Parser('tinkerforge call')
	device_choices = sorted(call_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			print('\n'.join(device_choices))
			parser.exit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--timeout', default=2500, type=int, help='maximum time (msec) to wait for response, default: 2500', metavar='<timeout>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	global timeout
	timeout = args.timeout

	call_devices[args.device](args.args)

def command_dispatch(argv):
	parser = Parser('tinkerforge dispatch')
	device_choices = sorted(dispatch_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			print('\n'.join(device_choices))
			parser.exit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--duration', default=-1, type=create_symbol_converter(int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate callbacks (exit-after-first: 0, forever: -1), default: forever', metavar='<duration>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	global duration
	duration = args.duration

	dispatch_devices[args.device](args.args)

def command_enumerate(argv):
	parser = Parser('tinkerforge enumerate')

	enumeration_type_symbols = {
	'available': IPConnection.ENUMERATION_TYPE_AVAILABLE,
	'connected': IPConnection.ENUMERATION_TYPE_CONNECTED,
	'disconnected': IPConnection.ENUMERATION_TYPE_DISCONNECTED
	}

	parser.add_argument('--duration', default=250, type=create_symbol_converter(int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate responses (exit-after-first: 0, forever: -1), default: 250', metavar='<duration>')
	parser.add_argument('--types', default=[IPConnection.ENUMERATION_TYPE_AVAILABLE], type=create_array_converter(create_symbol_converter(int, enumeration_type_symbols, True), 3, False), help='array of enumeration types to dispatch (available: 0, connected: 1, disconnected: 2), default: available', metavar='<types>')
	parser.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	args = parser.parse_args(argv)

	names = ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier', 'enumeration-type']
	enumeration_type_symbols = {
	IPConnection.ENUMERATION_TYPE_AVAILABLE: 'available',
	IPConnection.ENUMERATION_TYPE_CONNECTED: 'connected',
	IPConnection.ENUMERATION_TYPE_DISCONNECTED: 'disconnected'
	}
	symbols = [None, None, None, None, None, device_identifier_symbols, enumeration_type_symbols]
	is_first_callback = [True]

	if args.execute is not None:
		def callback(*values):
			if values[6] in args.types:
				values = format_symbolic_output(values, symbols)

				execute_result(args.execute, names, values)
				return True
	else:
		def callback(*values):
			if values[6] in args.types:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					sys.stdout.write(group_separator)

				values = format_symbolic_output(values, symbols)

				print_result(names, values)
				return True

	try:
		ipcon = IPConnection()
		ipcon.connect(host, port)

		if args.duration == 0:
			exit_flag = [False]

			def callback_wapper(*args, **kwargs):
				if not exit_flag[0] and callback(*args, **kwargs):
					exit_flag[0] = True

			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback_wapper)
			ipcon.enumerate()

			while not exit_flag[0]:
				time.sleep(0.1)
		elif args.duration < 0:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			while True:
				time.sleep(1)
		else:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			time.sleep(args.duration / 1000.0)
	except Error as e:
		fatal(e.description.lower(), 200 - e.value)
	except socket.error as e:
		fatal(str(e).lower(), 23)
	except Exception as e:
		fatal(str(e).lower(), 24)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def parse(argv):
	parser = Parser('tinkerforge', epilog="Try 'tinkerforge <command> --help' for command specific help.")
	command_choices = ['call', 'dispatch', 'enumerate']

	parser.add_argument('--version', action='version', version='<<VERSION>>')
	parser.add_argument('--host', default='localhost', type=str, help='IP address or hostname, default: localhost', metavar='<host>')
	parser.add_argument('--port', default=4223, type=int, help='port number, default: 4223', metavar='<port>')
	parser.add_argument('--item-separator', default=',', type=str, help='separator for array items, default: , (comma)', metavar='<item-separator>')
	parser.add_argument('--group-separator', default='\n', type=str, help='separator for output groups, default: \\n (newline)', metavar='<group-separator>')
	parser.add_argument('--no-symbolic-input', action='store_true', help='disable symbolic input of values')
	parser.add_argument('--no-symbolic-output', action='store_true', help='disable symbolic output of values')

	parser.add_argument('command', choices=command_choices, help='{' + ', '.join(command_choices) + '}', metavar='<command>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='command specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	global host
	host = args.host

	global port
	port = args.port

	global item_separator
	item_separator = args.item_separator
	item_separator = item_separator.replace('\\t', '\t')
	item_separator = item_separator.replace('\\r', '\r')
	item_separator = item_separator.replace('\\n', '\n')
	item_separator = item_separator.replace('\\\\', '\\')

	global group_separator
	group_separator = args.group_separator
	group_separator = group_separator.replace('\\t', '\t')
	group_separator = group_separator.replace('\\r', '\r')
	group_separator = group_separator.replace('\\n', '\n')
	group_separator = group_separator.replace('\\\\', '\\')

	global no_symbolic_input
	no_symbolic_input = args.no_symbolic_input

	global no_symbolic_output
	no_symbolic_output = args.no_symbolic_output

	commands = {
	'call': command_call,
	'dispatch': command_dispatch,
	'enumerate': command_enumerate
	}

	commands[args.command](args.args)

try:
	parse(sys.argv[1:])
except KeyboardInterrupt:
	sys.exit(3)

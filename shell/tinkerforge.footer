
def command_call(ctx, argv):
	parser = Parser(ctx, 'call')
	device_choices = sorted(call_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--timeout', default=2500, type=int, help='maximum time (msec) to wait for response, default: 2500', metavar='<timeout>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.timeout = args.timeout

	call_devices[args.device](ctx, args.args)

def command_dispatch(ctx, argv):
	parser = Parser(ctx, 'dispatch')
	device_choices = sorted(dispatch_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--duration', default=-1, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate callbacks (exit-after-first: 0, forever: -1), default: forever', metavar='<duration>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.duration = args.duration

	dispatch_devices[args.device](ctx, args.args)

def command_enumerate(ctx, argv):
	parser = Parser(ctx, 'enumerate')

	enumeration_type_symbols = {
	'available': IPConnection.ENUMERATION_TYPE_AVAILABLE,
	'connected': IPConnection.ENUMERATION_TYPE_CONNECTED,
	'disconnected': IPConnection.ENUMERATION_TYPE_DISCONNECTED
	}

	parser.add_argument('--duration', default=250, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate responses (exit-after-first: 0, forever: -1), default: 250', metavar='<duration>')
	parser.add_argument('--types', default=[IPConnection.ENUMERATION_TYPE_AVAILABLE], type=create_array_converter(ctx, create_symbol_converter(ctx, int, enumeration_type_symbols, True), 3, False), help='array of enumeration types to dispatch (available: 0, connected: 1, disconnected: 2), default: available', metavar='<types>')
	parser.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	args = parser.parse_args(argv)

	if dry_run:
		return

	names = ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier', 'enumeration-type']
	enumeration_type_symbols = {
	IPConnection.ENUMERATION_TYPE_AVAILABLE: 'available',
	IPConnection.ENUMERATION_TYPE_CONNECTED: 'connected',
	IPConnection.ENUMERATION_TYPE_DISCONNECTED: 'disconnected'
	}
	symbols = [None, None, None, None, None, device_identifier_symbols, enumeration_type_symbols]
	is_first_callback = [True]

	if args.execute is not None:
		def callback(*values):
			if values[6] in args.types:
				values = format_symbolic_output(ctx, values, symbols)

				execute_response(ctx, args.execute, names, values)
				return True
	else:
		def callback(*values):
			if values[6] in args.types:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					ctx.output(ctx.group_separator)

				values = format_symbolic_output(ctx, values, symbols)

				output_response(ctx, names, values)
				return True

	try:
		ipcon = IPConnection()
		ipcon.connect(ctx.host, ctx.port)

		if args.duration == 0:
			exit_flag = [False]

			def callback_wapper(*args, **kwargs):
				if not exit_flag[0] and callback(*args, **kwargs):
					exit_flag[0] = True

			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback_wapper)
			ipcon.enumerate()

			while not exit_flag[0]:
				time.sleep(0.1)
		elif args.duration < 0:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			while True:
				time.sleep(1)
		else:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			time.sleep(args.duration / 1000.0)
	except Error as e:
		raise FatalError(e.description.lower(), IPCONNECTION_ERROR_OFFSET - e.value)
	except socket.error as e:
		raise FatalError(str(e).lower(), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def parse(ctx, argv):
	global dry_run
	dry_run = os.getenv('TINKERFORGE_SHELL_BINDINGS_DRY_RUN', 0) != 0

	parser = Parser(ctx, '', epilog="Try 'tinkerforge <command> --help' for command specific help.")
	command_choices = ['call', 'dispatch', 'enumerate']

	parser.add_argument('--version', action='version', version='<<VERSION>>')
	parser.add_argument('--host', default='localhost', type=str, help='IP address or hostname to connect to, default: localhost', metavar='<host>')
	parser.add_argument('--port', default=4223, type=int, help='port number to connect to, default: 4223', metavar='<port>')
	parser.add_argument('--item-separator', default=',', type=str, help='separator for array items, default: , (comma)', metavar='<item-separator>')
	parser.add_argument('--group-separator', default='\n', type=str, help='separator for output groups, default: \\n (newline)', metavar='<group-separator>')
	parser.add_argument('--no-symbolic-input', action='store_true', help='disable symbolic input of values')
	parser.add_argument('--no-symbolic-output', action='store_true', help='disable symbolic output of values')

	parser.add_argument('command', choices=command_choices, help='{' + ', '.join(command_choices) + '}', metavar='<command>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='command specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.host = args.host
	ctx.port = args.port

	ctx.item_separator = args.item_separator
	ctx.item_separator = ctx.item_separator.replace('\\t', '\t')
	ctx.item_separator = ctx.item_separator.replace('\\r', '\r')
	ctx.item_separator = ctx.item_separator.replace('\\n', '\n')
	ctx.item_separator = ctx.item_separator.replace('\\\\', '\\')

	ctx.group_separator = args.group_separator
	ctx.group_separator = ctx.group_separator.replace('\\t', '\t')
	ctx.group_separator = ctx.group_separator.replace('\\r', '\r')
	ctx.group_separator = ctx.group_separator.replace('\\n', '\n')
	ctx.group_separator = ctx.group_separator.replace('\\\\', '\\')

	ctx.no_symbolic_input = args.no_symbolic_input
	ctx.no_symbolic_output = args.no_symbolic_output

	commands = {
	'call': command_call,
	'dispatch': command_dispatch,
	'enumerate': command_enumerate
	}

	commands[args.command](ctx, args.args)

def main():
	ctx = Context()

	try:
		parse(ctx, sys.argv[1:])
	except KeyboardInterrupt:
		sys.exit(1)
	except ParserExit:
		sys.exit(0)
	except FatalError as e:
		if ctx.current_parser is not None:
			prog = ctx.current_parser.prog
		else:
			prog = 'tinkerforge'

		sys.stderr.write('{0}: error: {1}\n'.format(prog, e.message))
		sys.exit(e.exit_code)

if __name__ == '__main__':
	main()
